Generating Access Token:

Endpoint: https://ims-na1.adobelogin.com/ims/exchange/jwt
Method: POST
Payload (Pass following parameters in the body):

{
  "client_id": "YOUR_CLIENT_ID",
  "client_secret": "YOUR_CLIENT_SECRET",
  "jwt_token": "YOUR_JWT_TOKEN"
}

Other details/Dependencies: 

ORGANIZATION_ID: To be exported in code fresh workspace
TECHNICAL_ACCOUNT_ID: To be exported in code fresh workspace
CLIENT_ID: To be exported in code fresh workspace
CLIENT_SECRET: To be exported in code fresh workspace
CM_PRIVATE_KEY: To be exported in code fresh workspace
YOUR_JWT_TOKEN: Will be autogenerated using CLIENT_ID and CLIENT_SECRET using script.

Expected HTTP Response:
2xx RC with following json object.
{
  "token_type": "bearer",
  "access_token": "{access_token}",
  "expires_in": "{expiration_time}"
}


Reference(s): 
https://developer.adobe.com/developer-console/docs/guides/authentication/JWT/#creating-a-json-web-token
https://experienceleague.adobe.com/docs/experience-platform/landing/platform-apis/api-authentication.html

Creating a Package:

Endpoint: {source_aem_instance}/crx/packmgr/service/.json/etc/packages/{group_name}/{package_name}.zip
Method: POST
Headers:
{
  "Authorization": f"Bearer {access_token}",
  "Content-Type": "application/x-www-form-urlencoded"
}

Query parameters:
{
  "cmd": "create"
}

Expected HTTP response:
2xx RC with json object containing package details.

Payload:
{
  "groupName": "my_packages",
  "packageName": "package_name",
  "version": "1.0",
  "paths": ["/content/sample", "/conf/sample", "/etc/designs/sample"]
}

Reference(s):
https://experienceleague.adobe.com/docs/experience-manager-65/administering/operations/curl.html?lang=en

Updating package filters (specify JCR paths to package)

Endpoint: {source_aem_instance}/crx/packmgr/update.jsp
Method: POST
Headers:
{
  "Authorization": f"Bearer {access_token}",
  "Content-Type": "application/x-www-form-urlencoded"
}

Payload (Pass following parameters in the body):

{
  "path": {PACKAGE_PATH},
  "packageName": {PACKAGE_NAME},  
  "groupName": {GROUP_NAME},
  "filter": {FILTERS},
  "_charset_": "UTF-8"
}

PACKAGE_PATH represents the path where the package is created.
# Example: /etc/packages/{group_name}/{package_name}.zip

FILTERS represents the a list of objects containing JCR paths. 
# Example list:

[
    {
        "root": "/content/siteA"
    },
    {
        "root": "/conf/myconfig"
    },
    {
        "root": "/etc/designs/mydesign"
    }
]

Other details/Dependencies: 
The build trigger in code fresh shall use a variable called 'CONTENT_PATHS' to accept a string with list of comma separated paths.
Example: "/content/siteA,/conf/myconfig,/etc/designs/mydesign". The script shall read this input to construct list of objects containing JCR paths and use it request body.

Reference(s):
https://experienceleague.adobe.com/docs/experience-manager-65/administering/operations/curl.html?lang=en
https://experienceleague.adobe.com/docs/experience-manager-cloud-manager/content/using/content-copy.html?lang=en#:~:text=to%20copy%20content.-,Log%20into%20Cloud%20Manager%20at%20my.cloudmanager.adobe.com,Content%20from%20the%20ellipsis%20menu.

Building a package:
Endpoint: {source_aem_instance}/crx/packmgr/service/.json/etc/packages/{GROUP_NAME}/{PACKAGE_NAME}.zip
Method: POST
Headers:
{
  "Authorization": f"Bearer {access_token}"
}

Query parameters:
{
  "cmd": "build"
}

Expected HTTP response:
2xx RC with json object containing package details.

Reference(s):
https://experienceleague.adobe.com/docs/experience-manager-65/administering/operations/curl.html?lang=en
https://experienceleague.adobe.com/docs/experience-manager-cloud-manager/content/using/content-copy.html?lang=en#:~:text=to%20copy%20content.-,Log%20into%20Cloud%20Manager%20at%20my.cloudmanager.adobe.com,Content%20from%20the%20ellipsis%20menu.

Downloading built package from source instance:
Endpoint: {source_aem_instance}/crx/packmgr/service/.json/etc/packages/{GROUP_NAME}/{PACKAGE_NAME}.zip
Method: GET
Headers:
{
  "Authorization": f"Bearer {access_token}"
}

Expected HTTP response:
2xx RC with byte content for package.zip in response body.

Reference(s):
https://experienceleague.adobe.com/docs/experience-manager-cloud-manager/content/using/content-copy.html?lang=en#:~:text=to%20copy%20content.-,Log%20into%20Cloud%20Manager%20at%20my.cloudmanager.adobe.com,Content%20from%20the%20ellipsis%20menu.

Uploading package to target instance:
Endpoint: {target_aem_instance}/crx/packmgr/service/.json
Method: POST
Headers:
{
  "Authorization": f"Bearer {access_token}",
  "Content-Type": "multipart/form-data"
}

Payload (Pass following parameters in the body):
{
  "cmd": "upload",
  "force": "true",
  "package": "<binary content of package to upload (package.zip)>"
}

Expected HTTP response:
2xx RC with json containing uploaded package details.

Reference(s):
https://experienceleague.adobe.com/docs/experience-manager-cloud-manager/content/using/content-copy.html?lang=en#:~:text=to%20copy%20content.-,Log%20into%20Cloud%20Manager%20at%20my.cloudmanager.adobe.com,Content%20from%20the%20ellipsis%20menu.

Installing Uploaded package to target instance:
Endpoint: {target_aem_instance}/crx/packmgr/service/.json/etc/packages/{group_name}/{package_name}.zip
Method: POST
Headers:
{
  "Authorization": f"Bearer {access_token}",
  "Content-Type": "application/x-www-form-urlencoded"
}

Payload (Pass following parameters in the body):
{
  "cmd": "install"
}

Expected HTTP response:
2xx RC with json containing uploaded package details.

Reference(s):
https://experienceleague.adobe.com/docs/experience-manager-cloud-manager/content/using/content-copy.html?lang=en#:~:text=to%20copy%20content.-,Log%20into%20Cloud%20Manager%20at%20my.cloudmanager.adobe.com,Content%20from%20the%20ellipsis%20menu.

Clear cache on target instance:
Endpoint: {target_aem_instance}/crx/packmgr/service/.json/etc/packages/{group_name}/{package_name}.zip
Method: POST
Headers:
{
  "Authorization": f"Bearer {access_token}",
  "CQ-Action": "Deactivate",
  'CQ-Handle': {CONTENT_PATH},
  'CQ-Path':   {CONTENT_PATH},
  "Content-Type": "application/octet-stream"
}

Other details/Dependencies: 
The Request does not specifying multiple CONTENT_PATH (JCR Paths) for which cache needs to be cleared/invalidated. Hence the script shall loop through the list of paths to make a cache clear request. The list of paths will be acquired from code fresh variable 'CONTENT_PATHS' containing string of comma separated paths as mentioned previously in the section titled 'Updating package filters'

Expected HTTP response:
2xx RC with json containing uploaded package details.

Reference(s):
https://experienceleague.adobe.com/docs/experience-manager-cloud-manager/content/using/content-copy.html?lang=en#:~:text=to%20copy%20content.-,Log%20into%20Cloud%20Manager%20at%20my.cloudmanager.adobe.com,Content%20from%20the%20ellipsis%20menu.


SCRIPT:
#!/usr/bin/python
import os
import jwt
import requests
import time
import argparse
import json

def get_access_token():
    claims = {
        "exp": int(time.time()) + 30 * 60,
        "iss": os.environ["ORGANIZATION_ID"],
        "sub": os.environ["TECHNICAL_ACCOUNT_ID"],
        "https://ims-na1.adobelogin.com/s/ent_cloudmgr_sdk": True,
        "aud": f"https://ims-na1.adobelogin.com/c/{os.environ['CLIENT_ID']}"
    }
    encoded_jwt = jwt.encode(claims, os.environ["CM_PRIVATE_KEY"].replace("\\n", "\n"), algorithm='RS256')
    
    response = requests.post("https://ims-na1.adobelogin.com/ims/exchange/jwt", data={
        "client_id": os.environ["CLIENT_ID"],
        "client_secret": os.environ["CLIENT_SECRET"],
        "jwt_token": encoded_jwt.decode("utf-8")
    })
    response.raise_for_status()
    return response.json()["access_token"]

def create_package(aem_instance, access_token):
    group_name = os.environ["CF_BUILD_INITIATOR"]
    package_name = f"{group_name}_package_{int(time.time())}"

    headers = {
        "Authorization": f"Bearer {access_token}",
        "Content-Type": "application/x-www-form-urlencoded"
    }

    params = {
        "cmd": "create"
    }
    
    # Formulate the endpoint URL with the desired groupName and packageName
    endpoint_url = f"{aem_instance}/crx/packmgr/service/.json/etc/packages/{group_name}/{package_name}.zip"
    
    response = requests.post(endpoint_url, headers=headers, params=params)
    response.raise_for_status()
    
    # Construct the package path based on AEM's conventional path structure
    return f"/etc/packages/{group_name}/{package_name}.zip"

def update_package_filters(aem_instance, access_token, package_path):
    filter_paths_str = os.environ["JCR_CONTENT_PATHS"]
    filter_paths_str = filter_paths_str.strip()
    filter_paths = [path.strip() for path in filter_paths_str.split(",")]
    allowed_prefixes = ["/content/", "/conf/", "/etc/", "/var/workflow/models/"]
    for path in filter_paths:
        if not any(path.startswith(prefix) for prefix in allowed_prefixes):
            raise ValueError(f"The path '{path}' is not allowed!")

    filters = [{"root": path} for path in filter_paths]
    filter_payload = json.dumps(filters)

    headers = {
        "Authorization": f"Bearer {access_token}",
        "Content-Type": "application/x-www-form-urlencoded"
    }

    payload = {
        "path": package_path,
        "filter": filter_payload,
        "_charset_": "utf-8"
    }

    response = requests.post(f"{aem_instance}/crx/packmgr/update.jsp", headers=headers, data=payload)
    response.raise_for_status()
    return response.json()

def build_package(aem_instance, access_token, package_path):
    HEADERS = {
        "Authorization": f"Bearer {access_token}",
        "Content-Type": "application/x-www-form-urlencoded"
    }
    
    payload = {
        "cmd": "build"
    }
    
    response = requests.post(f"{aem_instance}/crx/packmgr/service/.json{package_path}", data=payload, headers=HEADERS)
    response.raise_for_status()
    return response.json()

def download_package(aem_instance, access_token, package_path):
    headers = {
        "Authorization": f"Bearer {access_token}"
    }
    response = requests.get(f"{aem_instance}{package_path}", headers=headers)
    response.raise_for_status()

    # Extract package name from package_path
    package_name = os.path.basename(package_path)

    # Use the current working directory as the destination
    local_package_path = os.path.join(os.getcwd(), package_name)

    with open(abs_path, 'wb') as f:
        f.write(response.content)

    return local_package_path

def upload_and_install_package(aem_instance, access_token, local_package):
    HEADERS = {
        "Authorization": f"Bearer {access_token}",
    }
    
    with open(local_package, "rb") as f:
        payload = {
            "file": f,
            "name": os.path.basename(local_package),  # This gets the package name from the zip file's filename.
            "force": "true",
            "install": "true"
        }
        response = requests.post(
            f"{aem_instance}/crx/packmgr/service.jsp",
            headers=HEADERS,
            files=payload
        )
        response.raise_for_status()
        return response.text

def install_package(aem_instance, access_token, package_path):
    HEADERS = {
        "Authorization": f"Bearer {access_token}",
    }
    
    payload = {
        "cmd": "install"
    }
    response = requests.post(
        f"{aem_instance}/crx/packmgr/service/.json{package_path}",
        headers=HEADERS,
        data=payload
    )
    response.raise_for_status()
    return response.json()

def clear_cache(aem_instance, access_token, paths_string):
    headers = {
        "Authorization": f"Bearer {access_token}",
        "CQ-Action": "Deactivate",
        "Content-Type": "application/octet-stream"
    }
    content_path_string = os.environ["JCR_CONTENT_PATHS"]
    content_path_string = content_path_string.strip()
    paths = content_path_string.split(',')
    for path in paths:
        path = path.strip()
        headers["CQ-Handle"] = path
        headers["CQ-Path"] = path
        response = requests.post(f"{aem_instance}/dispatcher/invalidate.cache", headers=headers)
        response.raise_for_status()

    return True

def main():
    parser = argparse.ArgumentParser(description="AEM Content Sync and Cache Eviction Tool")
    parser.add_argument("--content_sync", action="store_true", help="Enable content synchronization")
    parser.add_argument("--clear_cache", action="store_true", help="Enable cache eviction")

    args = parser.parse_args()

    target_instance = os.environ["TARGET_AEM_INSTANCE"]

    # Generate the access token
    access_token = get_access_token()

    if args.content_sync:
        source_instance = os.environ["SOURCE_AEM_INSTANCE"]
        
        # Create the package on the source AEM instance
        package_path = create_package(source_instance, access_token)

        # Update package filters in source instance
        update_package_filters(source_instance, access_token, package_path)

        # Build package in source instance
        build_package(source_instance, access_token, package_path)

        # Download the package from the source AEM instance
        downloaded_package_path = download_package(source_instance, access_token, package_path)

        # Upload and install the package on the target AEM instance
        upload_and_install_package(target_instance, access_token, downloaded_package_path)

    if args.clear_cache:
        # Clear content cache on target instance.
        clear_cache(target_instance, access_token)


if __name__ == "__main__":
    main()




####### ALTERNATE OPTION THAT DOES NOT CALL  AUTH'r/PUBLISH'R DIRECTLY

import os
import jwt
import time
import requests
from retry import retry


def get_env_var(var_name):
    var_value = os.environ.get(var_name)
    if not var_value:
        raise ValueError(f"Environment variable {var_name} is not set")
    return var_value


IMS_API_ENDPOINT = "https://ims-na1.adobelogin.com"
CLOUD_MANAGER_API_ENDPOINT = "https://cloudmanager.adobe.io"


def get_access_token(organization_id, technical_account_id, client_id, client_secret, private_key):
    claims = {
        "exp": int(time.time()) + 30 * 60,
        "iss": organization_id,
        "sub": technical_account_id,
        "https://ims-na1.adobelogin.com/s/ent_cloudmgr_sdk": True,
        "aud": f"{IMS_API_ENDPOINT}/c/{client_id}"
    }
    encoded_jwt = jwt.encode(claims, private_key.replace("\\n", "\n"), algorithm='RS256')
    
    response = requests.post(f"{IMS_API_ENDPOINT}/ims/exchange/jwt", data={
        "client_id": client_id,
        "client_secret": client_secret,
        "jwt_token": encoded_jwt.decode("utf-8")
    })
    response.raise_for_status()
    return response.json()["access_token"]


@retry(tries=5, delay=10, backoff=2)
def create_content_set(token, program_id, paths, client_id):
    headers = {
        'Authorization': f'Bearer {token}',
        'x-gw-ims-org-id': organization_id,
        'x-api-key': client_id,
        'Content-Type': 'application/json'
    }
    payload = {"paths": [{"path": path} for path in paths]}

    response = requests.post(f"{CLOUD_MANAGER_API_ENDPOINT}/api/program/{program_id}/contentSet", headers=headers, json=payload)
    if response.status_code != 201:
        raise Exception(f"Failed to create content set: {response.text}")
    return response.json()["id"]


@retry(tries=5, delay=10, backoff=2)
def create_content_flow(token, program_id, content_set_id, src_environment_id, dest_environment_id, client_id):
    headers = {
        'Authorization': f'Bearer {token}',
        'x-gw-ims-org-id': organization_id,
        'x-api-key': client_id,
        'Content-Type': 'application/json'
    }
    payload = {
        "contentSetId": content_set_id,
        "srcEnvironmentId": src_environment_id,
        "destEnvironmentId": dest_environment_id
    }
    
    response = requests.post(f"{CLOUD_MANAGER_API_ENDPOINT}/api/program/{program_id}/contentFlow", headers=headers, json=payload)
    if response.status_code != 201:
        raise Exception(f"Failed to create content flow: {response.text}")
    return response.json()["id"]


@retry(tries=5, delay=10, backoff=2)
def check_content_flow_status(token, program_id, content_flow_id, client_id):
    headers = {
        'Authorization': f'Bearer {token}',
        'x-gw-ims-org-id': organization_id,
        'x-api-key': client_id
    }
    
    response = requests.get(f"{CLOUD_MANAGER_API_ENDPOINT}/api/program/{program_id}/contentFlow/{content_flow_id}", headers=headers)
    if response.status_code != 200:
        raise Exception(f"Failed to check content flow status: {response.text}")
    return response.json()["status"]


def main():
organization_id = get_env_var('ORGANIZATION_ID')
    technical_account_id = get_env_var('TECHNICAL_ACCOUNT_ID')
    client_id = get_env_var('CLIENT_ID')
    client_secret = get_env_var('CLIENT_SECRET')
    private_key = get_env_var('CM_PRIVATE_KEY')
    program_id = get_env_var('PROGRAM_ID')
    src_environment_id = get_env_var('SRC_ENVIRONMENT_ID')
    dest_environment_id = get_env_var('DEST_ENVIRONMENT_ID')
    jcr_content_paths = get_env_var('JCR_CONTENT_PATHS').split(',')

    token = get_access_token(organization_id, technical_account_id, client_id, client_secret, private_key)

    content_set_id = create_content_set(token, program_id, jcr_content_paths, client_id)
    content_flow_id = create_content_flow(token, program_id, content_set_id, src_environment_id, dest_environment_id, client_id)
    status = check_content_flow_status(token, program_id, content_flow_id, client_id)

    print(f"Content flow/sync Status: {status}")


if __name__ == "__main__":
    main()
