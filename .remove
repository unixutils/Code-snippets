Generating Access Token:

Endpoint: https://ims-na1.adobelogin.com/ims/exchange/jwt
Method: POST
Payload (Pass following parameters in the body):

{
  "client_id": "YOUR_CLIENT_ID",
  "client_secret": "YOUR_CLIENT_SECRET",
  "jwt_token": "YOUR_JWT_TOKEN"
}

Other details/Dependencies: 

ORGANIZATION_ID: To be exported in code fresh workspace
TECHNICAL_ACCOUNT_ID: To be exported in code fresh workspace
CLIENT_ID: To be exported in code fresh workspace
CLIENT_SECRET: To be exported in code fresh workspace
CM_PRIVATE_KEY: To be exported in code fresh workspace
YOUR_JWT_TOKEN: Will be autogenerated using CLIENT_ID and CLIENT_SECRET using script.

Expected HTTP Response:
2xx RC with following json object.
{
  "token_type": "bearer",
  "access_token": "{access_token}",
  "expires_in": "{expiration_time}"
}


Reference(s): 
https://developer.adobe.com/developer-console/docs/guides/authentication/JWT/#creating-a-json-web-token
https://experienceleague.adobe.com/docs/experience-platform/landing/platform-apis/api-authentication.html

Creating a Package:

Endpoint: {source_aem_instance}/crx/packmgr/service/.json/etc/packages/{group_name}/{package_name}.zip
Method: POST
Headers:
{
  "Authorization": f"Bearer {access_token}",
  "Content-Type": "application/x-www-form-urlencoded"
}

Query parameters:
{
  "cmd": "create"
}

Expected HTTP response:
2xx RC with json object containing package details.

Payload:
{
  "groupName": "my_packages",
  "packageName": "package_name",
  "version": "1.0",
  "paths": ["/content/sample", "/conf/sample", "/etc/designs/sample"]
}

Reference(s):
https://experienceleague.adobe.com/docs/experience-manager-65/administering/operations/curl.html?lang=en

Updating package filters (specify JCR paths to package)

Endpoint: {source_aem_instance}/crx/packmgr/update.jsp
Method: POST
Headers:
{
  "Authorization": f"Bearer {access_token}",
  "Content-Type": "application/x-www-form-urlencoded"
}

Payload (Pass following parameters in the body):

{
  "path": {PACKAGE_PATH},
  "packageName": {PACKAGE_NAME},  
  "groupName": {GROUP_NAME},
  "filter": {FILTERS},
  "_charset_": "UTF-8"
}

PACKAGE_PATH represents the path where the package is created.
# Example: /etc/packages/{group_name}/{package_name}.zip

FILTERS represents the a list of objects containing JCR paths. 
# Example list:

[
    {
        "root": "/content/siteA"
    },
    {
        "root": "/conf/myconfig"
    },
    {
        "root": "/etc/designs/mydesign"
    }
]

Other details/Dependencies: 
The build trigger in code fresh shall use a variable called 'CONTENT_PATHS' to accept a string with list of comma separated paths.
Example: "/content/siteA,/conf/myconfig,/etc/designs/mydesign". The script shall read this input to construct list of objects containing JCR paths and use it request body.

Reference(s):
https://experienceleague.adobe.com/docs/experience-manager-65/administering/operations/curl.html?lang=en
https://experienceleague.adobe.com/docs/experience-manager-cloud-manager/content/using/content-copy.html?lang=en#:~:text=to%20copy%20content.-,Log%20into%20Cloud%20Manager%20at%20my.cloudmanager.adobe.com,Content%20from%20the%20ellipsis%20menu.

Building a package:
Endpoint: {source_aem_instance}/crx/packmgr/service/.json/etc/packages/{GROUP_NAME}/{PACKAGE_NAME}.zip
Method: POST
Headers:
{
  "Authorization": f"Bearer {access_token}"
}

Query parameters:
{
  "cmd": "build"
}

Expected HTTP response:
2xx RC with json object containing package details.

Reference(s):
https://experienceleague.adobe.com/docs/experience-manager-65/administering/operations/curl.html?lang=en
https://experienceleague.adobe.com/docs/experience-manager-cloud-manager/content/using/content-copy.html?lang=en#:~:text=to%20copy%20content.-,Log%20into%20Cloud%20Manager%20at%20my.cloudmanager.adobe.com,Content%20from%20the%20ellipsis%20menu.

Downloading built package from source instance:
Endpoint: {source_aem_instance}/crx/packmgr/service/.json/etc/packages/{GROUP_NAME}/{PACKAGE_NAME}.zip
Method: GET
Headers:
{
  "Authorization": f"Bearer {access_token}"
}

Expected HTTP response:
2xx RC with byte content for package.zip in response body.

Reference(s):
https://experienceleague.adobe.com/docs/experience-manager-cloud-manager/content/using/content-copy.html?lang=en#:~:text=to%20copy%20content.-,Log%20into%20Cloud%20Manager%20at%20my.cloudmanager.adobe.com,Content%20from%20the%20ellipsis%20menu.

Uploading package to target instance:
Endpoint: {target_aem_instance}/crx/packmgr/service/.json
Method: POST
Headers:
{
  "Authorization": f"Bearer {access_token}",
  "Content-Type": "multipart/form-data"
}

Payload (Pass following parameters in the body):
{
  "cmd": "upload",
  "force": "true",
  "package": "<binary content of package to upload (package.zip)>"
}

Expected HTTP response:
2xx RC with json containing uploaded package details.

Reference(s):
https://experienceleague.adobe.com/docs/experience-manager-cloud-manager/content/using/content-copy.html?lang=en#:~:text=to%20copy%20content.-,Log%20into%20Cloud%20Manager%20at%20my.cloudmanager.adobe.com,Content%20from%20the%20ellipsis%20menu.

Installing Uploaded package to target instance:
Endpoint: {target_aem_instance}/crx/packmgr/service/.json/etc/packages/{group_name}/{package_name}.zip
Method: POST
Headers:
{
  "Authorization": f"Bearer {access_token}",
  "Content-Type": "application/x-www-form-urlencoded"
}

Payload (Pass following parameters in the body):
{
  "cmd": "install"
}

Expected HTTP response:
2xx RC with json containing uploaded package details.

Reference(s):
https://experienceleague.adobe.com/docs/experience-manager-cloud-manager/content/using/content-copy.html?lang=en#:~:text=to%20copy%20content.-,Log%20into%20Cloud%20Manager%20at%20my.cloudmanager.adobe.com,Content%20from%20the%20ellipsis%20menu.

Clear cache on target instance:
Endpoint: {target_aem_instance}/crx/packmgr/service/.json/etc/packages/{group_name}/{package_name}.zip
Method: POST
Headers:
{
  "Authorization": f"Bearer {access_token}",
  "CQ-Action": "Deactivate",
  'CQ-Handle': {CONTENT_PATH},
  'CQ-Path':   {CONTENT_PATH},
  "Content-Type": "application/octet-stream"
}

Other details/Dependencies: 
The Request does not specifying multiple CONTENT_PATH (JCR Paths) for which cache needs to be cleared/invalidated. Hence the script shall loop through the list of paths to make a cache clear request. The list of paths will be acquired from code fresh variable 'CONTENT_PATHS' containing string of comma separated paths as mentioned previously in the section titled 'Updating package filters'

Expected HTTP response:
2xx RC with json containing uploaded package details.

Reference(s):
https://experienceleague.adobe.com/docs/experience-manager-cloud-manager/content/using/content-copy.html?lang=en#:~:text=to%20copy%20content.-,Log%20into%20Cloud%20Manager%20at%20my.cloudmanager.adobe.com,Content%20from%20the%20ellipsis%20menu.


SCRIPT:
#!/usr/bin/python
import os
import jwt
import requests
import time
import argparse
import json

def get_access_token():
    claims = {
        "exp": int(time.time()) + 30 * 60,
        "iss": os.environ["ORGANIZATION_ID"],
        "sub": os.environ["TECHNICAL_ACCOUNT_ID"],
        "https://ims-na1.adobelogin.com/s/ent_cloudmgr_sdk": True,
        "aud": f"https://ims-na1.adobelogin.com/c/{os.environ['CLIENT_ID']}"
    }
    encoded_jwt = jwt.encode(claims, os.environ["CM_PRIVATE_KEY"].replace("\\n", "\n"), algorithm='RS256')
    
    response = requests.post("https://ims-na1.adobelogin.com/ims/exchange/jwt", data={
        "client_id": os.environ["CLIENT_ID"],
        "client_secret": os.environ["CLIENT_SECRET"],
        "jwt_token": encoded_jwt.decode("utf-8")
    })
    response.raise_for_status()
    return response.json()["access_token"]

def create_package(aem_instance, access_token):
    group_name = os.environ["CF_BUILD_INITIATOR"]
    package_name = f"{group_name}_package_{int(time.time())}"

    headers = {
        "Authorization": f"Bearer {access_token}",
        "Content-Type": "application/x-www-form-urlencoded"
    }

    params = {
        "cmd": "create"
    }
    
    # Formulate the endpoint URL with the desired groupName and packageName
    endpoint_url = f"{aem_instance}/crx/packmgr/service/.json/etc/packages/{group_name}/{package_name}.zip"
    
    response = requests.post(endpoint_url, headers=headers, params=params)
    response.raise_for_status()
    
    # Construct the package path based on AEM's conventional path structure
    return f"/etc/packages/{group_name}/{package_name}.zip"

def update_package_filters(aem_instance, access_token, package_path):
    filter_paths_str = os.environ["JCR_CONTENT_PATHS"]
    filter_paths_str = filter_paths_str.strip()
    filter_paths = [path.strip() for path in filter_paths_str.split(",")]
    allowed_prefixes = ["/content/", "/conf/", "/etc/", "/var/workflow/models/"]
    for path in filter_paths:
        if not any(path.startswith(prefix) for prefix in allowed_prefixes):
            raise ValueError(f"The path '{path}' is not allowed!")

    filters = [{"root": path} for path in filter_paths]
    filter_payload = json.dumps(filters)

    headers = {
        "Authorization": f"Bearer {access_token}",
        "Content-Type": "application/x-www-form-urlencoded"
    }

    payload = {
        "path": package_path,
        "filter": filter_payload,
        "_charset_": "utf-8"
    }

    response = requests.post(f"{aem_instance}/crx/packmgr/update.jsp", headers=headers, data=payload)
    response.raise_for_status()
    return response.json()

def build_package(aem_instance, access_token, package_path):
    HEADERS = {
        "Authorization": f"Bearer {access_token}",
        "Content-Type": "application/x-www-form-urlencoded"
    }
    
    payload = {
        "cmd": "build"
    }
    
    response = requests.post(f"{aem_instance}/crx/packmgr/service/.json{package_path}", data=payload, headers=HEADERS)
    response.raise_for_status()
    return response.json()

def download_package(aem_instance, access_token, package_path):
    headers = {
        "Authorization": f"Bearer {access_token}"
    }
    response = requests.get(f"{aem_instance}{package_path}", headers=headers)
    response.raise_for_status()

    # Extract package name from package_path
    package_name = os.path.basename(package_path)

    # Use the current working directory as the destination
    local_package_path = os.path.join(os.getcwd(), package_name)

    with open(abs_path, 'wb') as f:
        f.write(response.content)

    return local_package_path

def upload_and_install_package(aem_instance, access_token, local_package):
    HEADERS = {
        "Authorization": f"Bearer {access_token}",
    }
    
    with open(local_package, "rb") as f:
        payload = {
            "file": f,
            "name": os.path.basename(local_package),  # This gets the package name from the zip file's filename.
            "force": "true",
            "install": "true"
        }
        response = requests.post(
            f"{aem_instance}/crx/packmgr/service.jsp",
            headers=HEADERS,
            files=payload
        )
        response.raise_for_status()
        return response.text

def install_package(aem_instance, access_token, package_path):
    HEADERS = {
        "Authorization": f"Bearer {access_token}",
    }
    
    payload = {
        "cmd": "install"
    }
    response = requests.post(
        f"{aem_instance}/crx/packmgr/service/.json{package_path}",
        headers=HEADERS,
        data=payload
    )
    response.raise_for_status()
    return response.json()

def clear_cache(aem_instance, access_token, paths_string):
    headers = {
        "Authorization": f"Bearer {access_token}",
        "CQ-Action": "Deactivate",
        "Content-Type": "application/octet-stream"
    }
    content_path_string = os.environ["JCR_CONTENT_PATHS"]
    content_path_string = content_path_string.strip()
    paths = content_path_string.split(',')
    for path in paths:
        path = path.strip()
        headers["CQ-Handle"] = path
        headers["CQ-Path"] = path
        response = requests.post(f"{aem_instance}/dispatcher/invalidate.cache", headers=headers)
        response.raise_for_status()

    return True

def main():
    parser = argparse.ArgumentParser(description="AEM Content Sync and Cache Eviction Tool")
    parser.add_argument("--content_sync", action="store_true", help="Enable content synchronization")
    parser.add_argument("--clear_cache", action="store_true", help="Enable cache eviction")

    args = parser.parse_args()

    target_instance = os.environ["TARGET_AEM_INSTANCE"]

    # Generate the access token
    access_token = get_access_token()

    if args.content_sync:
        source_instance = os.environ["SOURCE_AEM_INSTANCE"]
        
        # Create the package on the source AEM instance
        package_path = create_package(source_instance, access_token)

        # Update package filters in source instance
        update_package_filters(source_instance, access_token, package_path)

        # Build package in source instance
        build_package(source_instance, access_token, package_path)

        # Download the package from the source AEM instance
        downloaded_package_path = download_package(source_instance, access_token, package_path)

        # Upload and install the package on the target AEM instance
        upload_and_install_package(target_instance, access_token, downloaded_package_path)

    if args.clear_cache:
        # Clear content cache on target instance.
        clear_cache(target_instance, access_token)


if __name__ == "__main__":
    main()




####### ALTERNATE OPTION THAT DOES NOT CALL  AUTH'r/PUBLISH'R DIRECTLY

import os
import jwt
import time
import requests
from retry import retry

IMS_API_ENDPOINT = "https://ims-na1.adobelogin.com"
CLOUD_MANAGER_API_ENDPOINT = "https://cloudmanager.adobe.io"

def get_env_var(var_name):
    var_value = os.environ.get(var_name)
    if not var_value:
        raise ValueError(f"Environment variable {var_name} is not set")
    return var_value

def decode_paths(encoded_string):
    decoded_paths = []
    paths = encoded_string.split(';')
    for path in paths:
        if '|' in path:
            main_path, exclusions = path.split('|', 1)
            exclusion_list = exclusions.split(',')
            decoded_paths.append({"path": main_path, "excluded": exclusion_list})
        else:
            decoded_paths.append({"path": path, "excluded": []})
    return decoded_paths

def get_access_token(organization_id, technical_account_id, client_id, client_secret, private_key):
    claims = {
        "exp": int(time.time()) + 30 * 60,
        "iss": organization_id,
        "sub": technical_account_id,
        "https://ims-na1.adobelogin.com/s/ent_cloudmgr_sdk": True,
        "aud": f"{IMS_API_ENDPOINT}/c/{client_id}"
    }
    encoded_jwt = jwt.encode(claims, private_key.replace("\\n", "\n"), algorithm='RS256')
    
    response = requests.post(f"{IMS_API_ENDPOINT}/ims/exchange/jwt", data={
        "client_id": client_id,
        "client_secret": client_secret,
        "jwt_token": encoded_jwt.decode("utf-8")
    })
    response.raise_for_status()
    return response.json()["access_token"]


@retry(tries=5, delay=10, backoff=2)
def create_content_set(token, program_id, paths, client_id, user_id):
    current_timestamp = datetime.datetime.now().strftime('%Y%m%d%H%M%S')
    content_set_name = f"content_set_{user_id}_{current_timestamp}"
    content_set_description = f"content_set_{user_id}_{current_timestamp} created using codefresh pipeline"

    headers = {
        'Authorization': f'Bearer {token}',
        'x-gw-ims-org-id': organization_id,
        'x-api-key': client_id,
        'Content-Type': 'application/json'
    }
    
    payload = {
        "name": content_set_name,
        "description": content_set_description,
        "paths": paths
    }

    response = requests.post(f"{CLOUD_MANAGER_API_ENDPOINT}/api/program/{program_id}/contentSet", headers=headers, json=payload)
    if response.status_code != 201:
        raise Exception(f"Failed to create content set: {response.text}")
    return response.json()["id"]


@retry(tries=5, delay=10, backoff=2)
def create_content_flow(token, src_program_id, src_environment_id, content_set_id, dest_environment_id, dest_program_id, tier, client_id):
    if tier not in ['author', 'publish']:
        raise ValueError("Invalid tier value. It should be either 'author' or 'publish'.")

    headers = {
        'Authorization': f'Bearer {token}',
        'x-gw-ims-org-id': organization_id,
        'x-api-key': client_id,
        'Content-Type': 'application/json'
    }

    payload = {
        "contentSetId": content_set_id,
        "destEnvironmentId": dest_environment_id,
        "tier": tier,
        "includeACL": False,
        "destProgramId": dest_program_id
    }

    response = requests.post(f"{CLOUD_MANAGER_API_ENDPOINT}/api/program/{src_program_id}/environment/{src_environment_id}/contentFlow", headers=headers, json=payload)
    if response.status_code != 201:
        raise Exception(f"Failed to create content flow: {response.text}")
    return response.json()["id"]


@retry(tries=5, delay=10, backoff=2)
def check_content_flow_status(token, program_id, content_flow_id, client_id):
    headers = {
        'Authorization': f'Bearer {token}',
        'x-gw-ims-org-id': organization_id,
        'x-api-key': client_id
    }
    
    response = requests.get(f"{CLOUD_MANAGER_API_ENDPOINT}/api/program/{program_id}/contentFlow/{content_flow_id}", headers=headers)
    if response.status_code != 200:
        raise Exception(f"Failed to check content flow status: {response.text}")
    return response.json()["status"]


def main():
    organization_id = get_env_var('ORGANIZATION_ID')
    technical_account_id = get_env_var('TECHNICAL_ACCOUNT_ID')
    client_id = get_env_var('CLIENT_ID')
    client_secret = get_env_var('CLIENT_SECRET')
    private_key = get_env_var('CM_PRIVATE_KEY')
    src_program_id = get_env_var('SRC_PROGRAM_ID')
    dest_program_id = get_env_var('DEST_PROGRAM_ID')
    src_environment_id = get_env_var('SRC_ENVIRONMENT_ID')
    dest_environment_id = get_env_var('DEST_ENVIRONMENT_ID')
    encoded_paths = get_env_var('JCR_CONTENT_PATHS')
    jcr_content_paths = decode_paths(encoded_paths)
    tier = get_env_var('TIER')

    token = get_access_token(organization_id, technical_account_id, client_id, client_secret, private_key)

    content_set_id = create_content_set(token, program_id_src, jcr_content_paths, client_id)
    content_flow_id = create_content_flow(token, src_program_id, src_environment_id, content_set_id, dest_environment_id, dest_program_id, tier, client_id)
    status = check_content_flow_status(token, program_id, content_flow_id, client_id)

    print(f"Content flow/sync Status: {status}")


if __name__ == "__main__":
    main()


------------------------------


provider "google" {
  // Your provider configuration here
}

// Enable the reCAPTCHA API
resource "google_project_service" "recaptcha_api" {
  service = "recaptchaenterprise.googleapis.com"
  disable_dependent_services = true
}

// Create an API key
resource "google_api_key" "my_api_key" {
  key_id      = "my-recaptcha-key"
  project     = "your-project-id"

  api_target {
    service = "recaptchaenterprise.googleapis.com"
  }

  restrictions {
    browser_key_restrictions {
      allowed_referrers = ["example1.com", "example2.com"]
    }
  }
}

// Create a service account
resource "google_service_account" "recaptcha_service_account" {
  account_id   = "recaptcha-service-account"
  display_name = "reCAPTCHA Service Account"
  project      = "your-project-id"
}

// Grant the service account access to reCAPTCHA API
resource "google_project_iam_binding" "recaptcha_iam" {
  role    = "roles/recaptchaenterprise.user"
  project = "your-project-id"

  members = [
    "serviceAccount:${google_service_account.recaptcha_service_account.email}"
  ]
}


----------------------

Frontend changes:

Example: ON USER INTERACTION

Create the request body and save it in a file named request.json. Be sure to make the following replacements:

TOKEN: The token returned from the grecaptcha.enterprise.execute() call.
USER_ACTION: Optional. The user-initiated action specified in the grecaptcha.enterprise.execute() call. Learn more about actions .
{
  "event": {
    "token": "TOKEN",
    "expectedAction": "USER_ACTION",
    "siteKey": "<SITE_KEY>",
  }
}
Send an HTTP POST request with the saved JSON data to the url below. Be sure to make the following replacements:

API_KEY: The API key associated with the current project
https://recaptchaenterprise.googleapis.com/v1/projects/<PROJECT_ID>/assessments?key=<API_KEY>

Evaluate specific user interactions to provide meaningful results. The example below shows how to protect a LOGIN action.

1. Load the JavaScript API within the head element of your web page:
<head>
  <script src="https://www.google.com/recaptcha/enterprise.js?render=<SITE_KEY>"></script>
  <!-- Your code -->
</head>

2. Add an execute call on the interaction:
<script>
  function onClick(e) {
    e.preventDefault();
    grecaptcha.enterprise.ready(async () => {
      const token = await grecaptcha.enterprise.execute('<SITE_KEY>', {action: 'LOGIN'});
    });
  }
</script>

The execute call generates a token. After the token is generated, send the reCAPTCHA Enterprise token to your application backend.

Example: ON AN HTML BUTTON

The example below uses a button and a named action to provide meaningful results.

1. Load the JavaScript API within the head element of your web page:
<head>
  <script src="https://www.google.com/recaptcha/enterprise.js?render=<SITE_KEY>"></script>
  <!-- Your code -->
</head>

2. Define a callback function to handle the token:
<!-- Replace the variables below. -->
<script>
  function onSubmit(token) {
    document.getElementById("demo-form").submit();
  }
</script>

3. Add attributes to your HTML button:
<button class="g-recaptcha"
    data-sitekey="<SITE_KEY>"
    data-callback='onSubmit'
    data-action='submit'>
  Submit
</button>

When this button is used to perform an action on your website, the g-recaptcha-response POST parameter contains the response token.
The execute call generates a token. After the token is generated, send the reCAPTCHA Enterprise token to your application backend.

Backend changes:

Create the request body:

TOKEN: The token returned from the grecaptcha.enterprise.execute() call from front end.

USER_ACTION: Optional. The user-initiated action specified in the grecaptcha.enterprise.execute() call. Learn more about actions .

{
  "event": {
    "token": "TOKEN",
    "expectedAction": "USER_ACTION",
    "siteKey": "<SITE_KEY>",
  }
}

Send an HTTP POST request with the created JSON data to the url below.

API_KEY: The API key associated with the current project
https://recaptchaenterprise.googleapis.com/v1/projects/<PROJECT_ID>/assessments?key=<API_KEY>
